#version 330 core
 
// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 normal;
in vec3 tangent;
in vec3 bitangent;
in vec3 position;
 
// Ouput data
out vec4 color;

struct DirLight {
	vec3 direction;
	vec3 diffuse;
	vec3 specular;
	float intensity;
};

struct PointLight {
	vec3 position;
	vec3 diffuse;
	vec3 specular;
	vec3 attenuation;
	float intensity;
};
 
 #define NUM_DIR_LIGHTS 100
 #define NUM_POINT_LIGHTS 100
// Values that stay constant for the whole mesh.
uniform sampler2D myTextureSampler;
uniform sampler2D DiffuseMap;
uniform sampler2D SpecularMap;
uniform sampler2D NormalMap;
uniform sampler2D EmissiveMap;
uniform sampler2D TransparencyMap;

uniform DirLight dirlights[NUM_DIR_LIGHTS];
uniform PointLight pointlights[NUM_POINT_LIGHTS];
uniform int numpointlights = 0;
uniform int numdirlights = 0;

uniform vec3 objectEmissiveColor = vec3(0,0,0);
uniform float objectGlow = 0.0f;
uniform vec3 lightAmbientColor = vec3(0,0,0);
uniform float objectReflectance = 0;
uniform float objectSpecFalloff = 20.0;
uniform vec3 objectSpecColor = vec3(1,1,1);
uniform float objectSpecIntensity = 1;
uniform float objectTransparency = 1;
uniform vec3 cameraVec;
 
void main(){

	
	vec3 totalColor = vec3(0,0,0);


	mat3 tangentSpaceMat = mat3(tangent, bitangent, normal);
	vec3 newNormal = normalize(tangentSpaceMat * normalize(texture( NormalMap, UV ).rgb * 2.0 - 1.0));
	// EMISSIVE COLOR
	vec3 emissiveColor = objectEmissiveColor * objectGlow * texture( EmissiveMap, UV ).rgb;
	totalColor += emissiveColor;

	// AMBIENT COLOR
	vec3 ambientColor = lightAmbientColor * objectReflectance;
	totalColor += ambientColor;

	// DIFFUSE COLOR
	for (int i = 0; i < numdirlights; i++)
	{
		float diffuseIntensity = dot(-dirlights[i].direction, newNormal);
		diffuseIntensity = clamp(diffuseIntensity, 0, 1);
		vec3 diffuseColor = texture( DiffuseMap, UV ).rgb * diffuseIntensity * dirlights[i].diffuse * dirlights[i].intensity;

		totalColor += diffuseColor;

		vec3 reflectionVector = dirlights[i].direction - dot(dirlights[i].direction, newNormal) * 2 * newNormal;
		float specintensity = dot(-cameraVec, normalize(reflectionVector));
		specintensity = clamp(specintensity, 0, 1);
		specintensity = pow(specintensity, objectSpecFalloff);
		specintensity *= diffuseIntensity;
		vec3 specularColor = dirlights[i].specular * objectSpecColor * specintensity * texture( SpecularMap, UV ).rgb;

		totalColor += specularColor;
		//totalColor += vec3(1,1,1);
	}

	for (int i = 0; i < numpointlights; i++)
	{
		vec3 pointLightDisp = position - pointlights[i].position;
		float pointlightdistance = length(pointLightDisp);
		vec3 pointlightdir = normalize(pointLightDisp);
		
		float attenuation = 1.0 / (pointlights[i].attenuation.x +
		pointlights[i].attenuation.y * pointlightdistance +
		pointlights[i].attenuation.z * pointlightdistance * pointlightdistance);

		float diffuseIntensity = dot(-pointlightdir, newNormal) * attenuation * pointlights[i].intensity;
		diffuseIntensity = clamp(diffuseIntensity, 0, 1);
		vec3 diffuseColor = texture( DiffuseMap, UV ).rgb * diffuseIntensity * pointlights[i].diffuse;
	
		totalColor += diffuseColor;

		vec3 reflectionVector = pointlightdir - dot(pointlightdir, newNormal) * 2 * newNormal;
		float specintensity = dot(-cameraVec, normalize(reflectionVector));
		specintensity = clamp(specintensity, 0, 1);
		specintensity = pow(specintensity, objectSpecFalloff);
		specintensity *= diffuseIntensity;
		vec3 specularColor = pointlights[i].specular * objectSpecColor * specintensity * texture( SpecularMap, UV ).rgb * attenuation * pointlights[i].intensity;
	
		totalColor += specularColor;
	}

	// TOTAL COLOR
    color = vec4(totalColor, length(texture( TransparencyMap, UV ).rgb) * objectTransparency);

}